<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavaBeanTesterWorker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">javabean-tester</a> &gt; <a href="index.source.html" class="el_package">com.codebox.bean</a> &gt; <span class="el_source">JavaBeanTesterWorker.java</span></div><h1>JavaBeanTesterWorker.java</h1><pre class="source lang-java linenums">/**
 * JavaBean Tester (https://github.com/hazendaz/javabean-tester)
 *
 * Copyright (c) 2012 - 2017 Hazendaz.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of The Apache Software License,
 * Version 2.0 which accompanies this distribution, and is available at
 * http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 * Contributors:
 *     CodeBox (Rob Dawson).
 *     Hazendaz (Jeremy Landis).
 */
package com.codebox.bean;

import com.codebox.enums.CanEquals;
import com.codebox.enums.CanSerialize;
import com.codebox.enums.LoadData;
import com.codebox.enums.LoadType;
import com.codebox.enums.SkipStrictSerialize;
import com.codebox.instance.ClassInstance;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import lombok.Data;

import net.sf.cglib.beans.BeanCopier;

import org.junit.jupiter.api.Assertions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The Class JavaBeanTesterWorker.
 *
 * @param &lt;T&gt;
 *            the generic type
 * @param &lt;E&gt;
 *            the element type
 */
<span class="pc bnc" id="L57" title="All 62 branches missed.">@Data</span>
class JavaBeanTesterWorker&lt;T, E&gt; {

    /** The Constant LOGGER. */
<span class="fc" id="L61">    private static final Logger LOGGER = LoggerFactory.getLogger(JavaBeanTesterWorker.class);</span>

    /** The serializable. */
<span class="nc" id="L64">    private CanSerialize checkSerializable;</span>

    /** The skip strict serialize. */
<span class="nc" id="L67">    private SkipStrictSerialize skipStrictSerializable;</span>

    /** The load data. */
<span class="nc" id="L70">    private LoadData loadData;</span>

    /** The check equals. */
<span class="nc" id="L73">    private CanEquals checkEquals;</span>

    /** The clazz. */
<span class="fc" id="L76">    private Class&lt;T&gt; clazz;</span>

    /** The extension. */
<span class="nc" id="L79">    private Class&lt;E&gt; extension;</span>

    /** The skip these. */
<span class="fc" id="L82">    private Set&lt;String&gt; skipThese = new HashSet&lt;&gt;();</span>

    /**
     * Instantiates a new java bean tester worker.
     *
     * @param newClazz
     *            the clazz
     */
<span class="fc" id="L90">    JavaBeanTesterWorker(final Class&lt;T&gt; newClazz) {</span>
<span class="fc" id="L91">        this.clazz = newClazz;</span>
<span class="fc" id="L92">    }</span>

    /**
     * Instantiates a new java bean tester worker.
     *
     * @param newClazz
     *            the clazz
     * @param newExtension
     *            the extension
     */
<span class="fc" id="L102">    JavaBeanTesterWorker(final Class&lt;T&gt; newClazz, final Class&lt;E&gt; newExtension) {</span>
<span class="fc" id="L103">        this.clazz = newClazz;</span>
<span class="fc" id="L104">        this.extension = newExtension;</span>
<span class="fc" id="L105">    }</span>

    /**
     * Tests the load methods of the specified class.
     *
     * @param &lt;L&gt;
     *            the type parameter associated with the class under test.
     * @param clazz
     *            the class under test.
     * @param instance
     *            the instance of class under test.
     * @param loadData
     *            load recursively all underlying data objects.
     * @param skipThese
     *            the names of any properties that should not be tested.
     * @return the java bean tester worker
     */
    public static &lt;L&gt; JavaBeanTesterWorker&lt;L, Object&gt; load(final Class&lt;L&gt; clazz, final L instance,
            final LoadData loadData, final String... skipThese) {
<span class="fc" id="L124">        final JavaBeanTesterWorker&lt;L, Object&gt; worker = new JavaBeanTesterWorker&lt;&gt;(clazz);</span>

<span class="fc" id="L126">        worker.setLoadData(loadData);</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (skipThese != null) {</span>
<span class="fc" id="L128">            worker.setSkipThese(new HashSet&lt;&gt;(Arrays.asList(skipThese)));</span>
        }
<span class="fc" id="L130">        worker.getterSetterTests(instance);</span>

<span class="fc" id="L132">        return worker;</span>
    }

    /**
     * Tests the get/set/equals/hashCode/toString methods and constructors of the specified class.
     */
    public void test() {
<span class="fc" id="L139">        this.getterSetterTests(new ClassInstance&lt;T&gt;().newInstance(this.clazz));</span>
<span class="fc" id="L140">        this.clearTest();</span>
<span class="fc" id="L141">        this.constructorsTest();</span>
<span class="fc" id="L142">        this.checkSerializableTest();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (this.checkEquals == CanEquals.ON) {</span>
<span class="fc" id="L144">            this.equalsHashCodeToStringSymmetricTest();</span>
        }
<span class="fc" id="L146">    }</span>

    /**
     * Getter Setter Tests.
     *
     * @param instance
     *            the instance of class under test.
     * @return the ter setter tests
     */
    void getterSetterTests(final T instance) {
        PropertyDescriptor[] props;
        try {
<span class="fc" id="L158">            props = Introspector.getBeanInfo(this.clazz).getPropertyDescriptors();</span>
<span class="nc" id="L159">        } catch (final IntrospectionException e) {</span>
<span class="nc" id="L160">            Assertions.fail(String.format(&quot;An exception was thrown while testing class '%s': '%s'&quot;,</span>
<span class="nc" id="L161">                    this.clazz.getName(), e.toString()));</span>
<span class="nc" id="L162">            return;</span>
<span class="fc" id="L163">        }</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        nextProp: for (final PropertyDescriptor prop : props) {</span>
            // Check the list of properties that we don't want to test
<span class="fc bfc" id="L166" title="All 2 branches covered.">            for (final String skipThis : this.skipThese) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                if (skipThis.equals(prop.getName())) {</span>
<span class="fc" id="L168">                    continue nextProp;</span>
                }
<span class="fc" id="L170">            }</span>
<span class="fc" id="L171">            final Method getter = prop.getReadMethod();</span>
<span class="fc" id="L172">            final Method setter = prop.getWriteMethod();</span>

<span class="pc bpc" id="L174" title="1 of 4 branches missed.">            if (getter != null &amp;&amp; setter != null) {</span>
                // We have both a get and set method for this property
<span class="fc" id="L176">                final Class&lt;?&gt; returnType = getter.getReturnType();</span>
<span class="fc" id="L177">                final Class&lt;?&gt;[] params = setter.getParameterTypes();</span>

<span class="pc bpc" id="L179" title="2 of 4 branches missed.">                if (params.length == 1 &amp;&amp; params[0] == returnType) {</span>
                    // The set method has 1 argument, which is of the same type as the return type of the get method, so
                    // we can test this property
                    try {
                        // Build a value of the correct type to be passed to the set method
<span class="fc" id="L184">                        final Object value = this.buildValue(returnType, LoadType.STANDARD_DATA);</span>

                        // Call the set method, then check the same value comes back out of the get method
<span class="fc" id="L187">                        setter.invoke(instance, value);</span>

<span class="fc" id="L189">                        final Object expectedValue = value;</span>
<span class="fc" id="L190">                        final Object actualValue = getter.invoke(instance);</span>

<span class="fc" id="L192">                        Assertions.assertEquals(expectedValue, actualValue,</span>
<span class="fc" id="L193">                                String.format(&quot;Failed while testing property '%s'&quot;, prop.getName()));</span>

<span class="nc" id="L195">                    } catch (final IllegalAccessException | IllegalArgumentException | InvocationTargetException</span>
                            | SecurityException e) {
<span class="nc" id="L197">                        Assertions.fail(String.format(</span>
                                &quot;An exception was thrown while testing the property (getter/setter) '%s': '%s'&quot;,
<span class="nc" id="L199">                                prop.getName(), e.toString()));</span>
<span class="fc" id="L200">                    }</span>
                }
            }
        }
<span class="fc" id="L204">    }</span>

    /**
     * Clear test.
     */
    void clearTest() {
<span class="fc" id="L210">        final Method[] methods = this.clazz.getDeclaredMethods();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (final Method method : methods) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (method.getName().equals(&quot;clear&quot;)) {</span>
<span class="fc" id="L213">                final T newClass = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
                try {
<span class="fc" id="L215">                    newClass.getClass().getMethod(&quot;clear&quot;).invoke(newClass);</span>
<span class="fc" id="L216">                    Assertions.assertEquals(new ClassInstance&lt;T&gt;().newInstance(this.clazz), newClass,</span>
<span class="fc" id="L217">                            String.format(&quot;Clear method does not match new object '%s'&quot;, this.clazz));</span>
<span class="nc" id="L218">                } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException</span>
                        | NoSuchMethodException | SecurityException e) {
<span class="nc" id="L220">                    Assertions.fail(String.format(&quot;An exception was thrown while testing the Clear method '%s' : '%s'&quot;,</span>
<span class="nc" id="L221">                            this.clazz.getName(), e.toString()));</span>
<span class="fc" id="L222">                }</span>
            }
        }
<span class="fc" id="L225">    }</span>

    /**
     * Constructors test.
     */
    void constructorsTest() {
<span class="fc bfc" id="L231" title="All 2 branches covered.">        for (final Constructor&lt;?&gt; constructor : this.clazz.getConstructors()) {</span>

            // Skip deprecated constructors
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">            if (constructor.isAnnotationPresent(Deprecated.class)) {</span>
<span class="nc" id="L235">                continue;</span>
            }

<span class="fc" id="L238">            final Class&lt;?&gt;[] types = constructor.getParameterTypes();</span>

<span class="fc" id="L240">            final Object[] values = new Object[constructor.getParameterTypes().length];</span>

            // Load Data
<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L244">                values[i] = this.buildValue(types[i], LoadType.STANDARD_DATA);</span>
            }

            try {
<span class="fc" id="L248">                constructor.newInstance(values);</span>
<span class="nc" id="L249">            } catch (final InstantiationException | IllegalAccessException | InvocationTargetException e) {</span>
<span class="nc" id="L250">                Assertions.fail(</span>
<span class="nc" id="L251">                        String.format(&quot;An exception was thrown while testing the constructor(s) '%s' with '%s': '%s'&quot;,</span>
<span class="nc" id="L252">                                constructor.getName(), Arrays.toString(values), e.toString()));</span>
<span class="fc" id="L253">            }</span>

            // TODO: Add checking of new object properties
        }
<span class="fc" id="L257">    }</span>

    /**
     * Check Serializable test.
     */
    void checkSerializableTest() {
<span class="fc" id="L263">        final T object = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (this.implementsSerializable(object)) {</span>
<span class="fc" id="L265">            final T newObject = this.canSerialize(object);</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (this.skipStrictSerializable != SkipStrictSerialize.ON) {</span>
<span class="fc" id="L267">                Assertions.assertEquals(object, newObject);</span>
            } else {
<span class="fc" id="L269">                Assertions.assertNotEquals(object, newObject);</span>
            }
<span class="fc" id="L271">            return;</span>
        }
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (this.checkSerializable == CanSerialize.ON) {</span>
<span class="nc" id="L274">            Assertions.fail(String.format(&quot;Class is not serializable '%s'&quot;, object.getClass().getName()));</span>
        }
<span class="fc" id="L276">    }</span>

    /**
     * Implements serializable.
     *
     * @param object
     *            the object
     * @return true, if successful
     */
    boolean implementsSerializable(final T object) {
<span class="pc bpc" id="L286" title="1 of 4 branches missed.">        return object instanceof Serializable || object instanceof Externalizable;</span>
    }

    /**
     * Can serialize.
     *
     * @param object
     *            the object
     * @return object read after serialization
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    T canSerialize(final T object) {
        // Serialize data
<span class="fc" id="L299">        final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
        try {
<span class="fc" id="L301">            new ObjectOutputStream(baos).writeObject(object);</span>
<span class="nc" id="L302">        } catch (final IOException e) {</span>
<span class="nc" id="L303">            Assertions.fail(String.format(&quot;An exception was thrown while serializing the class '%s': '%s',&quot;,</span>
<span class="nc" id="L304">                    object.getClass().getName(), e.toString()));</span>
<span class="nc" id="L305">            return null;</span>
<span class="fc" id="L306">        }</span>

        // Deserialize Data
<span class="fc" id="L309">        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span>
        try {
<span class="fc" id="L311">            return (T) new ObjectInputStream(bais).readObject();</span>
<span class="nc" id="L312">        } catch (final ClassNotFoundException | IOException e) {</span>
<span class="nc" id="L313">            Assertions.fail(String.format(&quot;An exception was thrown while deserializing the class '%s': '%s',&quot;,</span>
<span class="nc" id="L314">                    object.getClass().getName(), e.toString()));</span>
        }
<span class="nc" id="L316">        return null;</span>
    }

    /**
     * Builds the value.
     *
     * @param &lt;R&gt;
     *            the generic type
     * @param returnType
     *            the return type
     * @param loadType
     *            the load type
     * @return the object
     */
    private &lt;R&gt; Object buildValue(final Class&lt;R&gt; returnType, final LoadType loadType) {
<span class="fc" id="L331">        final ValueBuilder valueBuilder = new ValueBuilder();</span>
<span class="fc" id="L332">        valueBuilder.setLoadData(this.loadData);</span>
<span class="fc" id="L333">        return valueBuilder.buildValue(returnType, loadType);</span>
    }

    /**
     * Tests the equals/hashCode/toString methods of the specified class.
     */
    public void equalsHashCodeToStringSymmetricTest() {
        // Create Instances
<span class="fc" id="L341">        final T x = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc" id="L342">        final T y = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>

        // TODO Internalize extension will require canEquals, equals, hashcode, and toString overrides.
        /*
         * try { this.extension = (Class&lt;E&gt;) new ExtensionBuilder&lt;T&gt;().generate(this.clazz); } catch (NotFoundException
         * e) { Assert.fail(e.getMessage()); } catch (CannotCompileException e) { Assert.fail(e.getMessage()); }
         */
<span class="fc" id="L349">        final E ext = new ClassInstance&lt;E&gt;().newInstance(this.extension);</span>

        // Test Empty Equals, HashCode, and ToString
<span class="fc" id="L352">        Assertions.assertEquals(x, y);</span>
<span class="fc" id="L353">        Assertions.assertEquals(x.hashCode(), y.hashCode());</span>
<span class="fc" id="L354">        Assertions.assertEquals(x.toString(), y.toString());</span>

        // Test Extension Empty Equals, HashCode, and ToString
<span class="fc" id="L357">        Assertions.assertNotEquals(ext, y);</span>
<span class="fc" id="L358">        Assertions.assertNotEquals(ext.hashCode(), y.hashCode());</span>

        // Test Empty One Sided Tests
<span class="fc" id="L361">        Assertions.assertNotEquals(x, null);</span>
<span class="fc" id="L362">        Assertions.assertEquals(x, x);</span>

        // Test Extension Empty One Sided Tests
<span class="fc" id="L365">        Assertions.assertNotEquals(ext, null);</span>
<span class="fc" id="L366">        Assertions.assertEquals(ext, ext);</span>

        // Populate Side X
<span class="fc" id="L369">        JavaBeanTesterWorker.load(this.clazz, x, this.loadData);</span>

        // Populate Extension Side E
<span class="fc" id="L372">        JavaBeanTesterWorker.load(this.extension, ext, this.loadData);</span>

        // ReTest Equals (flip)
<span class="fc" id="L375">        Assertions.assertNotEquals(y, x);</span>

        // ReTest Extension Equals (flip)
<span class="fc" id="L378">        Assertions.assertNotEquals(y, ext);</span>

        // Populate Size Y
<span class="fc" id="L381">        JavaBeanTesterWorker.load(this.clazz, y, this.loadData);</span>

        // ReTest Equals and HashCode
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (this.loadData == LoadData.ON) {</span>
<span class="fc" id="L385">            Assertions.assertEquals(x, y);</span>
<span class="fc" id="L386">            Assertions.assertEquals(x.hashCode(), y.hashCode());</span>
        } else {
<span class="fc" id="L388">            Assertions.assertNotEquals(x, y);</span>
<span class="fc" id="L389">            Assertions.assertNotEquals(x.hashCode(), y.hashCode());</span>
        }

        // ReTest Extension Equals and HashCode
<span class="fc" id="L393">        Assertions.assertNotEquals(ext, y);</span>
<span class="fc" id="L394">        Assertions.assertNotEquals(ext.hashCode(), y.hashCode());</span>
<span class="fc" id="L395">        Assertions.assertNotEquals(ext.toString(), y.toString());</span>

        // Create Immutable Instance
        try {
<span class="fc" id="L399">            final BeanCopier clazzBeanCopier = BeanCopier.create(this.clazz, this.clazz, false);</span>
<span class="fc" id="L400">            final T e = new ClassInstance&lt;T&gt;().newInstance(this.clazz);</span>
<span class="fc" id="L401">            clazzBeanCopier.copy(x, e, null);</span>
<span class="fc" id="L402">            Assertions.assertEquals(e, x);</span>
<span class="nc" id="L403">        } catch (final Exception e) {</span>
<span class="nc" id="L404">            JavaBeanTesterWorker.LOGGER.trace(&quot;Do nothing class is not mutable&quot;, e.toString());</span>
<span class="fc" id="L405">        }</span>

        // Create Extension Immutable Instance
        try {
<span class="fc" id="L409">            final BeanCopier extensionBeanCopier = BeanCopier.create(this.extension, this.extension, false);</span>
<span class="fc" id="L410">            final E e2 = new ClassInstance&lt;E&gt;().newInstance(this.extension);</span>
<span class="fc" id="L411">            extensionBeanCopier.copy(ext, e2, null);</span>
<span class="fc" id="L412">            Assertions.assertEquals(e2, ext);</span>
<span class="fc" id="L413">        } catch (final Exception e) {</span>
<span class="fc" id="L414">            JavaBeanTesterWorker.LOGGER.trace(&quot;Do nothing class is not mutable&quot;, e.toString());</span>
<span class="fc" id="L415">        }</span>
<span class="fc" id="L416">    }</span>

    /**
     * Equals Tests will traverse one object changing values until all have been tested against another object. This is
     * done to effectively test all paths through equals.
     *
     * @param instance
     *            the class instance under test.
     * @param expected
     *            the instance expected for tests.
     */
    void equalsTests(final T instance, final T expected) {

        // Perform hashCode test dependent on data coming in
        // Assert.assertEquals(expected.hashCode(), instance.hashCode());
<span class="fc bfc" id="L431" title="All 2 branches covered.">        if (expected.hashCode() == instance.hashCode()) {</span>
<span class="fc" id="L432">            Assertions.assertEquals(expected.hashCode(), instance.hashCode());</span>
        } else {
<span class="fc" id="L434">            Assertions.assertNotEquals(expected.hashCode(), instance.hashCode());</span>
        }

<span class="fc" id="L437">        final ValueBuilder valueBuilder = new ValueBuilder();</span>
<span class="fc" id="L438">        valueBuilder.setLoadData(this.loadData);</span>

        PropertyDescriptor[] props;
        try {
<span class="fc" id="L442">            props = Introspector.getBeanInfo(instance.getClass()).getPropertyDescriptors();</span>
<span class="nc" id="L443">        } catch (final IntrospectionException e) {</span>
<span class="nc" id="L444">            Assertions.fail(String.format(&quot;An exception occurred during introspection of '%s': '%s'&quot;,</span>
<span class="nc" id="L445">                    instance.getClass().getName(), e.toString()));</span>
<span class="nc" id="L446">            return;</span>
<span class="fc" id="L447">        }</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">        for (final PropertyDescriptor prop : props) {</span>
<span class="fc" id="L449">            final Method getter = prop.getReadMethod();</span>
<span class="fc" id="L450">            final Method setter = prop.getWriteMethod();</span>

<span class="pc bpc" id="L452" title="1 of 4 branches missed.">            if (getter != null &amp;&amp; setter != null) {</span>
                // We have both a get and set method for this property
<span class="fc" id="L454">                final Class&lt;?&gt; returnType = getter.getReturnType();</span>
<span class="fc" id="L455">                final Class&lt;?&gt;[] params = setter.getParameterTypes();</span>

<span class="pc bpc" id="L457" title="2 of 4 branches missed.">                if (params.length == 1 &amp;&amp; params[0] == returnType) {</span>
                    // The set method has 1 argument, which is of the same type as the return type of the get method, so
                    // we can test this property
                    try {
                        // Save original value
<span class="fc" id="L462">                        final Object original = getter.invoke(instance);</span>

                        // Build a value of the correct type to be passed to the set method using alternate test
<span class="fc" id="L465">                        Object value = valueBuilder.buildValue(returnType, LoadType.ALTERNATE_DATA);</span>

                        // Call the set method, then check the same value comes back out of the get method
<span class="fc" id="L468">                        setter.invoke(instance, value);</span>

                        // Check equals depending on data
<span class="fc bfc" id="L471" title="All 2 branches covered.">                        if (instance.equals(expected)) {</span>
<span class="fc" id="L472">                            Assertions.assertEquals(expected, instance);</span>
                        } else {
<span class="fc" id="L474">                            Assertions.assertNotEquals(expected, instance);</span>
                        }

                        // Build a value of the correct type to be passed to the set method using null test
<span class="fc" id="L478">                        value = valueBuilder.buildValue(returnType, LoadType.NULL_DATA);</span>

                        // Call the set method, then check the same value comes back out of the get method
<span class="fc" id="L481">                        setter.invoke(instance, value);</span>

                        // Check equals depending on data
<span class="fc bfc" id="L484" title="All 2 branches covered.">                        if (instance.equals(expected)) {</span>
<span class="fc" id="L485">                            Assertions.assertEquals(expected, instance);</span>
                        } else {
<span class="fc" id="L487">                            Assertions.assertNotEquals(expected, instance);</span>
                        }

                        // Reset to original value
<span class="fc" id="L491">                        setter.invoke(instance, original);</span>

<span class="nc" id="L493">                    } catch (final IllegalAccessException | IllegalArgumentException | InvocationTargetException</span>
                            | SecurityException e) {
<span class="nc" id="L495">                        Assertions.fail(</span>
<span class="nc" id="L496">                                String.format(&quot;An exception was thrown while testing the property (equals) '%s': '%s'&quot;,</span>
<span class="nc" id="L497">                                        prop.getName(), e.toString()));</span>
<span class="fc" id="L498">                    }</span>
                }
            }
        }
<span class="fc" id="L502">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>